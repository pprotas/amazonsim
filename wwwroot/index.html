<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>SimulationView</title>
</head>

<body style="margin:0px;padding:0px;overflow:hidden;">


    <script>
        function parseCommand(input = "") {
            return JSON.parse(input);
        }

        var exampleSocket;

        window.onload = function () {
            var camera, scene, renderer;
            var cameraControls;
            var robot1;
            var robotCounter = 0;
            var worldObjects = {};
            var robots = [];
            var points = [];
            var lights = new THREE.Group();
            var i = 1;

            function loadOBJModel(modelPath, modelName, texturePath, textureName, onload) {
                new THREE.MTLLoader()
                    .setPath(texturePath)
                    .load(textureName, function (materials) {
                        materials.preload();

                        new THREE.OBJLoader()
                            .setPath(modelPath)
                            .setMaterials(materials)
                            .load(modelName, function (object) {
                                onload(object);
                            }, function () { }, function (e) { console.log("Error loading model"); console.log(e); });
                    });
            }

            function direction(current, desired) {
                if ((desired - current) == 0) {
                    return 0;
                }
                else if ((desired - current) < 0) {
                    return -0.1;
                }
                else if ((desired - current) > 0) {
                    return 0.1;
                }
            }

            function round(number) {
                return Math.round(number * 10) / 10;
            }

            function move(robot, point) {
                if (robot.position.x != point.point.position.x) {
                    robot.position.x += direction(robot.position.x, point.point.position.x);
                    robot.position.x = round(robot.position.x);
                }
                if (robot.position.y != point.point.position.y) {
                    robot.position.y += direction(robot.position.y, point.point.position.y);
                    robot.position.y = round(robot.position.y);
                }
                if (robot.position.z != point.point.position.z) {
                    robot.position.z += direction(robots[0].position.z, point.point.position.z);
                    robot.position.z = round(robot.position.z);
                }
                // if (round(point.point.position.x - robot.position.x) == 0 && round(point.point.position.y - robot.position.y) == 0 && round(point.point.position.z - robot.position.z) == 0) {
                //     robot.position.set(point.point.position.x, point.point.position.y, point.point.position.z);
                //     console.log("x: " + robot.position.x + " y: " + robot.position.y + " z: " + robot.position.z);
                // }
                if(robot.position.x === point.point.position.x && robot.position.y === point.point.position.y && robot.position.z === point.point.position.z){
                    robot.position.set(point.point.position.x, point.point.position.y, point.point.position.z);
                }
                console.log("Desired point: " + i + point.point.name);
                console.log("x: " + robot.position.x + " y: " + robot.position.y + " z: " + robot.position.z);
            }

            function goThroughPoints(robot, pointList) {
                if (robot !== undefined && pointList[i] !== undefined) {
                    move(robot, pointList[i]);
                    if (round(pointList[i].point.position.x - robot.position.x) == 0 && round(pointList[i].point.position.y - robot.position.y) == 0 && round(pointList[i].point.position.z - robot.position.z) == 0) {
                        if (i === 9) {
                            i = 0;
                        }
                        else {
                            i++;
                        }
                    }
                }
            }

            function init() {
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000);
                cameraControls = new THREE.OrbitControls(camera);
                camera.position.z = 15;
                camera.position.y = 5;
                camera.position.x = 15;
                cameraControls.update();
                scene = new THREE.Scene();

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight + 5);
                document.body.appendChild(renderer.domElement);

                window.addEventListener('resize', onWindowResize, false);

                var geometry = new THREE.PlaneGeometry(30, 30, 32);
                var material = new THREE.MeshPhongMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                var plane = new THREE.Mesh(geometry, material);
                plane.rotation.x = Math.PI / 2.0;
                plane.position.x = 0;
                plane.position.z = 0;
                scene.add(plane);


                var light = new THREE.PointLight(0xffffff, 2.5);
                lights.add(light);
                light.position.set(10, 4, 10);
                var pointLightHelper = new THREE.PointLightHelper(light, 1, 0xff0000);
                lights.add(pointLightHelper);
                light2 = new THREE.AmbientLight(0x404040, 2);
                lights.add(light2);
                scene.add(lights);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function animate() {
                requestAnimationFrame(animate);
                cameraControls.update();
                renderer.render(scene, camera);
                lights.updateMatrix();
                lights.updateMatrixWorld();
                goThroughPoints(robots[0], points);
            }

            exampleSocket = new WebSocket("ws://" + window.location.hostname + ":5000" + "/connect_client");
            exampleSocket.onmessage = function (event) {
                var command = parseCommand(event.data);
                if (command.command == "point") {
                    var point = new THREE.Group();
                    point.name = command.parameters.name;
                    point.position.x = command.parameters.x;
                    point.position.y = command.parameters.y;
                    point.position.z = command.parameters.z;
                    points.push({ connection1: command.parameters.connection1, connection2: command.parameters.connection1, connection3: command.parameters.connection1, point });
                }
                else if (command.command == "update") {
                    var models = new THREE.Group();
                    scene.add(models);
                    if (Object.keys(worldObjects).indexOf(command.parameters.guid) < 0) {
                        if (command.parameters.type == "robot") {
                            var robot = new THREE.Group();
                            loadOBJModel("models/", "DomesticRobot_1293.obj", "textures/", "DomesticRobot_1293.mtl", (mesh) => {
                                mesh.scale.set(0.05, 0.05, 0.05);
                                robot.add(mesh);
                                robot.material = new THREE.MeshPhongMaterial;
                                models.add(robot);
                            });
                            worldObjects[command.parameters.guid] = robot;
                            robots.push(worldObjects[command.parameters.guid]);
                        }
                        if (command.parameters.type == "rack") {
                            var rack = new THREE.Group();
                            loadOBJModel("models/", "CatModel.obj", "textures/", "CatModel.mtl", (mesh) => {
                                mesh.scale.set(0.005, 0.005, 0.005);
                                mesh.rotation.set(Math.PI * 1.5, 0, 0);
                                rack.add(mesh);
                                models.add(rack);
                            });
                            worldObjects[command.parameters.guid] = rack;
                        }
                    }
                    var object = worldObjects[command.parameters.guid];

                    object.position.x = command.parameters.x;
                    object.position.y = command.parameters.y;
                    object.position.z = command.parameters.z;

                    object.rotation.x = command.parameters.rotationX;
                    object.rotation.y = command.parameters.rotationY;
                    object.rotation.z = command.parameters.rotationZ;
                }
            }
            init();
            animate();
        }
    </script>

    <script src="three.min.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="MTLLoader.js"></script>
    <script src="OBJLoader.js"></script>
</body>

</html>